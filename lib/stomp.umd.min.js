import _regeneratorRuntime from "babel-runtime/regenerator";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("StompJs", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.StompJs = t() : e.StompJs = t();
}("undefined" != typeof self ? self : this, function () {
  return function (e) {
    var t = {};function s(n) {
      if (t[n]) return t[n].exports;var i = t[n] = { i: n, l: !1, exports: {} };return e[n].call(i.exports, i, i.exports, s), i.l = !0, i.exports;
    }return s.m = e, s.c = t, s.d = function (e, t, n) {
      s.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });
    }, s.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, s.t = function (e, t) {
      if (1 & t && (e = s(e)), 8 & t) return e;if (4 & t && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && e && e.__esModule) return e;var n = Object.create(null);if (s.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var i in e) {
        s.d(n, i, function (t) {
          return e[t];
        }.bind(null, i));
      }return n;
    }, s.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return s.d(t, "a", t), t;
    }, s.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, s.p = "", s(s.s = 0);
  }([function (e, t, s) {
    e.exports = s(1);
  }, function (e, t, s) {
    "use strict";
    s.r(t), s.d(t, "Client", function () {
      return u;
    }), s.d(t, "FrameImpl", function () {
      return o;
    }), s.d(t, "Parser", function () {
      return r;
    }), s.d(t, "StompConfig", function () {
      return m;
    }), s.d(t, "StompHeaders", function () {
      return _;
    }), s.d(t, "StompSubscription", function () {
      return b;
    }), s.d(t, "StompSocketState", function () {
      return c;
    }), s.d(t, "ActivationState", function () {
      return a;
    }), s.d(t, "Versions", function () {
      return h;
    }), s.d(t, "CompatClient", function () {
      return p;
    }), s.d(t, "Stomp", function () {
      return y;
    });var n = "\n",
        i = "\0";
    var o = function () {
      function o(e) {
        _classCallCheck(this, o);

        var t = e.command,
            s = e.headers,
            n = e.body,
            i = e.binaryBody,
            _o = e.escapeHeaderValues,
            r = e.skipContentLengthHeader;
        this.command = t, this.headers = Object.assign({}, s || {}), i ? (this._binaryBody = i, this.isBinaryBody = !0) : (this._body = n || "", this.isBinaryBody = !1), this.escapeHeaderValues = _o || !1, this.skipContentLengthHeader = r || !1;
      }

      _createClass(o, [{
        key: "toString",
        value: function toString() {
          return this.serializeCmdAndHeaders();
        }
      }, {
        key: "serialize",
        value: function serialize() {
          var e = this.serializeCmdAndHeaders();return this.isBinaryBody ? o.toUnit8Array(e, this._binaryBody).buffer : e + this._body + i;
        }
      }, {
        key: "serializeCmdAndHeaders",
        value: function serializeCmdAndHeaders() {
          var e = [this.command];this.skipContentLengthHeader && delete this.headers["content-length"];var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = Object.keys(this.headers || {})[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _t = _step.value;
              var _s = this.headers[_t];this.escapeHeaderValues && "CONNECT" !== this.command && "CONNECTED" !== this.command ? e.push(_t + ":" + o.hdrValueEscape("" + _s)) : e.push(_t + ":" + _s);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return (this.isBinaryBody || !this.isBodyEmpty() && !this.skipContentLengthHeader) && e.push("content-length:" + this.bodyLength()), e.join(n) + n + n;
        }
      }, {
        key: "isBodyEmpty",
        value: function isBodyEmpty() {
          return 0 === this.bodyLength();
        }
      }, {
        key: "bodyLength",
        value: function bodyLength() {
          var e = this.binaryBody;return e ? e.length : 0;
        }
      }, {
        key: "body",
        get: function get() {
          return !this._body && this.isBinaryBody && (this._body = new TextDecoder().decode(this._binaryBody)), this._body;
        }
      }, {
        key: "binaryBody",
        get: function get() {
          return this._binaryBody || this.isBinaryBody || (this._binaryBody = new TextEncoder().encode(this._body)), this._binaryBody;
        }
      }], [{
        key: "fromRawFrame",
        value: function fromRawFrame(e, t) {
          var s = {},
              n = function n(e) {
            return e.replace(/^\s+|\s+$/g, "");
          };var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = e.headers.reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _i = _step2.value;
              _i.indexOf(":");var _r = n(_i[0]);var _c = n(_i[1]);t && "CONNECT" !== e.command && "CONNECTED" !== e.command && (_c = o.hdrValueUnEscape(_c)), s[_r] = _c;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          return new o({ command: e.command, headers: s, binaryBody: e.binaryBody, escapeHeaderValues: t });
        }
      }, {
        key: "sizeOfUTF8",
        value: function sizeOfUTF8(e) {
          return e ? new TextEncoder().encode(e).length : 0;
        }
      }, {
        key: "toUnit8Array",
        value: function toUnit8Array(e, t) {
          var s = new TextEncoder().encode(e),
              n = new Uint8Array([0]),
              i = new Uint8Array(s.length + t.length + n.length);return i.set(s), i.set(t, s.length), i.set(n, s.length + t.length), i;
        }
      }, {
        key: "marshall",
        value: function marshall(e) {
          return new o(e).serialize();
        }
      }, {
        key: "hdrValueEscape",
        value: function hdrValueEscape(e) {
          return e.replace(/\\/g, "\\\\").replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/:/g, "\\c");
        }
      }, {
        key: "hdrValueUnEscape",
        value: function hdrValueUnEscape(e) {
          return e.replace(/\\r/g, "\r").replace(/\\n/g, "\n").replace(/\\c/g, ":").replace(/\\\\/g, "\\");
        }
      }]);

      return o;
    }();

    var r = function () {
      function r(e, t) {
        _classCallCheck(this, r);

        this.onFrame = e, this.onIncomingPing = t, this._encoder = new TextEncoder(), this._decoder = new TextDecoder(), this._token = [], this._initState();
      }

      _createClass(r, [{
        key: "parseChunk",
        value: function parseChunk(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
          var s = void 0;if (s = e instanceof ArrayBuffer ? new Uint8Array(e) : this._encoder.encode(e), t && 0 !== s[s.length - 1]) {
            var _e = new Uint8Array(s.length + 1);_e.set(s, 0), _e[s.length] = 0, s = _e;
          }for (var _e2 = 0; _e2 < s.length; _e2++) {
            var _t2 = s[_e2];this._onByte(_t2);
          }
        }
      }, {
        key: "_collectFrame",
        value: function _collectFrame(e) {
          0 !== e && 13 !== e && (10 !== e ? (this._onByte = this._collectCommand, this._reinjectByte(e)) : this.onIncomingPing());
        }
      }, {
        key: "_collectCommand",
        value: function _collectCommand(e) {
          if (13 !== e) return 10 === e ? (this._results.command = this._consumeTokenAsUTF8(), void (this._onByte = this._collectHeaders)) : void this._consumeByte(e);
        }
      }, {
        key: "_collectHeaders",
        value: function _collectHeaders(e) {
          13 !== e && (10 !== e ? (this._onByte = this._collectHeaderKey, this._reinjectByte(e)) : this._setupCollectBody());
        }
      }, {
        key: "_reinjectByte",
        value: function _reinjectByte(e) {
          this._onByte(e);
        }
      }, {
        key: "_collectHeaderKey",
        value: function _collectHeaderKey(e) {
          if (58 === e) return this._headerKey = this._consumeTokenAsUTF8(), void (this._onByte = this._collectHeaderValue);this._consumeByte(e);
        }
      }, {
        key: "_collectHeaderValue",
        value: function _collectHeaderValue(e) {
          if (13 !== e) return 10 === e ? (this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]), this._headerKey = void 0, void (this._onByte = this._collectHeaders)) : void this._consumeByte(e);
        }
      }, {
        key: "_setupCollectBody",
        value: function _setupCollectBody() {
          var e = this._results.headers.filter(function (e) {
            return "content-length" === e[0];
          })[0];e ? (this._bodyBytesRemaining = parseInt(e[1], 10), this._onByte = this._collectBodyFixedSize) : this._onByte = this._collectBodyNullTerminated;
        }
      }, {
        key: "_collectBodyNullTerminated",
        value: function _collectBodyNullTerminated(e) {
          0 !== e ? this._consumeByte(e) : this._retrievedBody();
        }
      }, {
        key: "_collectBodyFixedSize",
        value: function _collectBodyFixedSize(e) {
          0 != this._bodyBytesRemaining-- ? this._consumeByte(e) : this._retrievedBody();
        }
      }, {
        key: "_retrievedBody",
        value: function _retrievedBody() {
          this._results.binaryBody = this._consumeTokenAsRaw(), this.onFrame(this._results), this._initState();
        }
      }, {
        key: "_consumeByte",
        value: function _consumeByte(e) {
          this._token.push(e);
        }
      }, {
        key: "_consumeTokenAsUTF8",
        value: function _consumeTokenAsUTF8() {
          return this._decoder.decode(this._consumeTokenAsRaw());
        }
      }, {
        key: "_consumeTokenAsRaw",
        value: function _consumeTokenAsRaw() {
          var e = new Uint8Array(this._token);return this._token = [], e;
        }
      }, {
        key: "_initState",
        value: function _initState() {
          this._results = { command: void 0, headers: [], binaryBody: void 0 }, this._token = [], this._headerKey = void 0, this._onByte = this._collectFrame;
        }
      }]);

      return r;
    }();

    var c, a;!function (e) {
      e[e.CONNECTING = 0] = "CONNECTING", e[e.OPEN = 1] = "OPEN", e[e.CLOSING = 2] = "CLOSING", e[e.CLOSED = 3] = "CLOSED";
    }(c || (c = {})), function (e) {
      e[e.ACTIVE = 0] = "ACTIVE", e[e.DEACTIVATING = 1] = "DEACTIVATING", e[e.INACTIVE = 2] = "INACTIVE";
    }(a || (a = {}));
    var h = function () {
      function h(e) {
        _classCallCheck(this, h);

        this.versions = e;
      }

      _createClass(h, [{
        key: "supportedVersions",
        value: function supportedVersions() {
          return this.versions.join(",");
        }
      }, {
        key: "protocolVersions",
        value: function protocolVersions() {
          return this.versions.map(function (e) {
            return "v" + e.replace(".", "") + ".stomp";
          });
        }
      }]);

      return h;
    }();

    h.V1_0 = "1.0", h.V1_1 = "1.1", h.V1_2 = "1.2", h.default = new h([h.V1_0, h.V1_1, h.V1_2]);
    var d = function () {
      function d(e, t) {
        var _this = this;

        var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, d);

        this._client = e, this._webSocket = t, this._serverFrameHandlers = { CONNECTED: function CONNECTED(e) {
            _this.debug("connected to server " + e.headers.server), _this._connected = !0, _this._connectedVersion = e.headers.version, _this._connectedVersion === h.V1_2 && (_this._escapeHeaderValues = !0), _this._setupHeartbeat(e.headers), _this.onConnect(e);
          }, MESSAGE: function MESSAGE(e) {
            var t = e.headers.subscription,
                s = _this._subscriptions[t] || _this.onUnhandledMessage,
                n = e,
                i = _this,
                o = _this._connectedVersion === h.V1_2 ? n.headers.ack : n.headers["message-id"];n.ack = function () {
              var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return i.ack(o, t, e);
            }, n.nack = function () {
              var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return i.nack(o, t, e);
            }, s(n);
          }, RECEIPT: function RECEIPT(e) {
            var t = _this._receiptWatchers[e.headers["receipt-id"]];t ? (t(e), delete _this._receiptWatchers[e.headers["receipt-id"]]) : _this.onUnhandledReceipt(e);
          }, ERROR: function ERROR(e) {
            _this.onStompError(e);
          } }, this._counter = 0, this._subscriptions = {}, this._receiptWatchers = {}, this._partialData = "", this._escapeHeaderValues = !1, this._lastServerActivityTS = Date.now(), this.configure(s);
      }

      _createClass(d, [{
        key: "configure",
        value: function configure(e) {
          Object.assign(this, e);
        }
      }, {
        key: "start",
        value: function start() {
          var _this2 = this;

          var e = new r(function (e) {
            var t = o.fromRawFrame(e, _this2._escapeHeaderValues);_this2.logRawCommunication || _this2.debug("<<< " + t);(_this2._serverFrameHandlers[t.command] || _this2.onUnhandledFrame)(t);
          }, function () {
            _this2.debug("<<< PONG");
          });this._webSocket.onmessage = function (t) {
            if (_this2.debug("Received data"), _this2._lastServerActivityTS = Date.now(), _this2.logRawCommunication) {
              var _e3 = t.data instanceof ArrayBuffer ? new TextDecoder().decode(t.data) : t.data;_this2.debug("<<< " + _e3);
            }e.parseChunk(t.data, _this2.appendMissingNULLonIncoming);
          }, this._onclose = function (e) {
            _this2.debug("Connection closed to " + _this2._client.brokerURL), _this2._cleanUp(), _this2.onWebSocketClose(e);
          }, this._webSocket.onclose = this._onclose, this._webSocket.onerror = function (e) {
            _this2.onWebSocketError(e);
          }, this._webSocket.onopen = function () {
            var e = Object.assign({}, _this2.connectHeaders);_this2.debug("Web Socket Opened..."), e["accept-version"] = _this2.stompVersions.supportedVersions(), e["heart-beat"] = [_this2.heartbeatOutgoing, _this2.heartbeatIncoming].join(","), _this2._transmit({ command: "CONNECT", headers: e });
          };
        }
      }, {
        key: "_setupHeartbeat",
        value: function _setupHeartbeat(e) {
          var _this3 = this;

          if (e.version !== h.V1_1 && e.version !== h.V1_2) return;if (!e["heart-beat"]) return;
          var _e$heartBeat$split$m = e["heart-beat"].split(",").map(function (e) {
            return parseInt(e, 10);
          }),
              _e$heartBeat$split$m2 = _slicedToArray(_e$heartBeat$split$m, 2),
              t = _e$heartBeat$split$m2[0],
              s = _e$heartBeat$split$m2[1];

          if (0 !== this.heartbeatOutgoing && 0 !== s) {
            var _e4 = Math.max(this.heartbeatOutgoing, s);this.debug("send PING every " + _e4 + "ms"), this._pinger = setInterval(function () {
              _this3._webSocket.readyState === c.OPEN && (_this3._webSocket.send(n), _this3.debug(">>> PING"));
            }, _e4);
          }if (0 !== this.heartbeatIncoming && 0 !== t) {
            var _e5 = Math.max(this.heartbeatIncoming, t);this.debug("check PONG every " + _e5 + "ms"), this._ponger = setInterval(function () {
              var t = Date.now() - _this3._lastServerActivityTS;t > 2 * _e5 && (_this3.debug("did not receive server activity for the last " + t + "ms"), _this3._closeOrDiscardWebsocket());
            }, _e5);
          }
        }
      }, {
        key: "_closeOrDiscardWebsocket",
        value: function _closeOrDiscardWebsocket() {
          this.discardWebsocketOnCommFailure ? (this.debug("Discarding websocket, the underlying socket may linger for a while"), this._discardWebsocket()) : (this.debug("Issuing close on the websocket"), this._closeWebsocket());
        }
      }, {
        key: "forceDisconnect",
        value: function forceDisconnect() {
          this._webSocket && (this._webSocket.readyState !== c.CONNECTING && this._webSocket.readyState !== c.OPEN || this._closeOrDiscardWebsocket());
        }
      }, {
        key: "_closeWebsocket",
        value: function _closeWebsocket() {
          this._webSocket.onmessage = function () {}, this._webSocket.close();
        }
      }, {
        key: "_discardWebsocket",
        value: function _discardWebsocket() {
          var _this4 = this;

          var e, t;this._webSocket.terminate || (e = this._webSocket, t = function t(e) {
            return _this4.debug(e);
          }, e.terminate = function () {
            var e = function e() {};this.onerror = e, this.onmessage = e, this.onopen = e;var s = new Date(),
                n = this.onclose;this.onclose = function (e) {
              var n = new Date().getTime() - s.getTime();t("Discarded socket closed after " + n + "ms, with code/reason: " + e.code + "/" + e.reason);
            }, this.close(), n.call(this, { code: 4001, reason: "Heartbeat failure, discarding the socket", wasClean: !1 });
          }), this._webSocket.terminate();
        }
      }, {
        key: "_transmit",
        value: function _transmit(e) {
          var t = e.command,
              s = e.headers,
              n = e.body,
              i = e.binaryBody,
              r = e.skipContentLengthHeader,
              c = new o({ command: t, headers: s, body: n, binaryBody: i, escapeHeaderValues: this._escapeHeaderValues, skipContentLengthHeader: r });
          var a = c.serialize();if (this.logRawCommunication ? this.debug(">>> " + a) : this.debug(">>> " + c), this.forceBinaryWSFrames && "string" == typeof a && (a = new TextEncoder().encode(a)), "string" == typeof a && this.splitLargeFrames) {
            var _e6 = a;for (; _e6.length > 0;) {
              var _t3 = _e6.substring(0, this.maxWebSocketChunkSize);_e6 = _e6.substring(this.maxWebSocketChunkSize), this._webSocket.send(_t3), this.debug("chunk sent = " + _t3.length + ", remaining = " + _e6.length);
            }
          } else this._webSocket.send(a);
        }
      }, {
        key: "dispose",
        value: function dispose() {
          var _this5 = this;

          if (this.connected) try {
            var _e7 = Object.assign({}, this.disconnectHeaders);_e7.receipt || (_e7.receipt = "close-" + this._counter++), this.watchForReceipt(_e7.receipt, function (e) {
              _this5._closeWebsocket(), _this5._cleanUp(), _this5.onDisconnect(e);
            }), this._transmit({ command: "DISCONNECT", headers: _e7 });
          } catch (e) {
            this.debug("Ignoring error during disconnect " + e);
          } else this._webSocket.readyState !== c.CONNECTING && this._webSocket.readyState !== c.OPEN || this._closeWebsocket();
        }
      }, {
        key: "_cleanUp",
        value: function _cleanUp() {
          this._connected = !1, this._pinger && clearInterval(this._pinger), this._ponger && clearInterval(this._ponger);
        }
      }, {
        key: "publish",
        value: function publish(e) {
          var t = e.destination,
              s = e.headers,
              n = e.body,
              i = e.binaryBody,
              o = e.skipContentLengthHeader,
              r = Object.assign({ destination: t }, s);
          this._transmit({ command: "SEND", headers: r, body: n, binaryBody: i, skipContentLengthHeader: o });
        }
      }, {
        key: "watchForReceipt",
        value: function watchForReceipt(e, t) {
          this._receiptWatchers[e] = t;
        }
      }, {
        key: "subscribe",
        value: function subscribe(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          (s = Object.assign({}, s)).id || (s.id = "sub-" + this._counter++), s.destination = e, this._subscriptions[s.id] = t, this._transmit({ command: "SUBSCRIBE", headers: s });var n = this;return { id: s.id, unsubscribe: function unsubscribe(e) {
              return n.unsubscribe(s.id, e);
            } };
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          t = Object.assign({}, t), delete this._subscriptions[e], t.id = e, this._transmit({ command: "UNSUBSCRIBE", headers: t });
        }
      }, {
        key: "begin",
        value: function begin(e) {
          var t = e || "tx-" + this._counter++;this._transmit({ command: "BEGIN", headers: { transaction: t } });var s = this;return { id: t, commit: function commit() {
              s.commit(t);
            },
            abort: function abort() {
              s.abort(t);
            }
          };
        }
      }, {
        key: "commit",
        value: function commit(e) {
          this._transmit({ command: "COMMIT", headers: { transaction: e } });
        }
      }, {
        key: "abort",
        value: function abort(e) {
          this._transmit({ command: "ABORT", headers: { transaction: e } });
        }
      }, {
        key: "ack",
        value: function ack(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          s = Object.assign({}, s), this._connectedVersion === h.V1_2 ? s.id = e : s["message-id"] = e, s.subscription = t, this._transmit({ command: "ACK", headers: s });
        }
      }, {
        key: "nack",
        value: function nack(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return s = Object.assign({}, s), this._connectedVersion === h.V1_2 ? s.id = e : s["message-id"] = e, s.subscription = t, this._transmit({ command: "NACK", headers: s });
        }
      }, {
        key: "connectedVersion",
        get: function get() {
          return this._connectedVersion;
        }
      }, {
        key: "connected",
        get: function get() {
          return this._connected;
        }
      }]);

      return d;
    }();

    var l = function l(e, t, s, n) {
      return new (s || (s = Promise))(function (i, o) {
        function r(e) {
          try {
            a(n.next(e));
          } catch (e) {
            o(e);
          }
        }function c(e) {
          try {
            a(n.throw(e));
          } catch (e) {
            o(e);
          }
        }function a(e) {
          var t;e.done ? i(e.value) : (t = e.value, t instanceof s ? t : new s(function (e) {
            e(t);
          })).then(r, c);
        }a((n = n.apply(e, t || [])).next());
      });
    };
    var u = function () {
      function u() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, u);

        this.stompVersions = h.default, this.connectionTimeout = 1e4, this.reconnectDelay = 5e3, this.heartbeatIncoming = 1e4, this.heartbeatOutgoing = 1e4, this.splitLargeFrames = !1, this.maxWebSocketChunkSize = 8192, this.forceBinaryWSFrames = !1, this.appendMissingNULLonIncoming = !1, this.state = a.INACTIVE;var t = function t() {};this.debug = t, this.beforeConnect = t, this.onConnect = t, this.onDisconnect = t, this.onUnhandledMessage = t, this.onUnhandledReceipt = t, this.onUnhandledFrame = t, this.onStompError = t, this.onWebSocketClose = t, this.onWebSocketError = t, this.logRawCommunication = !1, this.onChangeState = t, this.connectHeaders = {}, this._disconnectHeaders = {}, this.configure(e);
      }

      _createClass(u, [{
        key: "_changeState",
        value: function _changeState(e) {
          this.state = e, this.onChangeState(e);
        }
      }, {
        key: "configure",
        value: function configure(e) {
          Object.assign(this, e);
        }
      }, {
        key: "activate",
        value: function activate() {
          if (this.state === a.DEACTIVATING) throw this.debug("Still DEACTIVATING, please await call to deactivate before trying to re-activate"), new Error("Still DEACTIVATING, can not activate now");this.active ? this.debug("Already ACTIVE, ignoring request to activate") : (this._changeState(a.ACTIVE), this._connect());
        }
      }, {
        key: "_connect",
        value: function _connect() {
          return l(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
            var _this6 = this;

            var e;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.connected) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return", void this.debug("STOMP: already connected, nothing to do"));

                  case 2:
                    _context.next = 4;
                    return this.beforeConnect();

                  case 4:
                    if (this.active) {
                      _context.next = 6;
                      break;
                    }

                    return _context.abrupt("return", void this.debug("Client has been marked inactive, will not attempt to connect"));

                  case 6:
                    this.connectionTimeout > 0 && (this._connectionWatcher = setTimeout(function () {
                      _this6.debug("Connection not established in " + _this6.connectionTimeout + "ms, closing socket"), _this6.forceDisconnect();
                    }, this.connectionTimeout)), this.debug("Opening Web Socket...");e = this._createWebSocket();
                    this._stompHandler = new d(this, e, { debug: this.debug, stompVersions: this.stompVersions, connectHeaders: this.connectHeaders, disconnectHeaders: this._disconnectHeaders, heartbeatIncoming: this.heartbeatIncoming, heartbeatOutgoing: this.heartbeatOutgoing, splitLargeFrames: this.splitLargeFrames, maxWebSocketChunkSize: this.maxWebSocketChunkSize, forceBinaryWSFrames: this.forceBinaryWSFrames, logRawCommunication: this.logRawCommunication, appendMissingNULLonIncoming: this.appendMissingNULLonIncoming, discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure, onConnect: function onConnect(e) {
                        if (_this6._connectionWatcher && (clearTimeout(_this6._connectionWatcher), _this6._connectionWatcher = void 0), !_this6.active) return _this6.debug("STOMP got connected while deactivate was issued, will disconnect now"), void _this6._disposeStompHandler();_this6.onConnect(e);
                      }, onDisconnect: function onDisconnect(e) {
                        _this6.onDisconnect(e);
                      }, onStompError: function onStompError(e) {
                        _this6.onStompError(e);
                      }, onWebSocketClose: function onWebSocketClose(e) {
                        _this6._stompHandler = void 0, _this6.state === a.DEACTIVATING && (_this6._resolveSocketClose(), _this6._resolveSocketClose = void 0, _this6._changeState(a.INACTIVE)), _this6.onWebSocketClose(e), _this6.active && _this6._schedule_reconnect();
                      }, onWebSocketError: function onWebSocketError(e) {
                        _this6.onWebSocketError(e);
                      }, onUnhandledMessage: function onUnhandledMessage(e) {
                        _this6.onUnhandledMessage(e);
                      }, onUnhandledReceipt: function onUnhandledReceipt(e) {
                        _this6.onUnhandledReceipt(e);
                      }, onUnhandledFrame: function onUnhandledFrame(e) {
                        _this6.onUnhandledFrame(e);
                      } }), this._stompHandler.start();
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
        }
      }, {
        key: "_createWebSocket",
        value: function _createWebSocket() {
          var e = void 0;return e = this.webSocketFactory ? this.webSocketFactory() : new WebSocket(this.brokerURL, this.stompVersions.protocolVersions()), e.binaryType = "arraybuffer", e;
        }
      }, {
        key: "_schedule_reconnect",
        value: function _schedule_reconnect() {
          var _this7 = this;

          this.reconnectDelay > 0 && (this.debug("STOMP: scheduling reconnection in " + this.reconnectDelay + "ms"), this._reconnector = setTimeout(function () {
            _this7._connect();
          }, this.reconnectDelay));
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          return l(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
            var _this8 = this;

            var e;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    e = void 0;
                    return _context2.abrupt("return", this.state !== a.ACTIVE ? (this.debug("Already " + a[this.state] + ", ignoring call to deactivate"), Promise.resolve()) : (this._changeState(a.DEACTIVATING), this._reconnector && clearTimeout(this._reconnector), this._stompHandler && this.webSocket.readyState !== c.CLOSED ? (e = new Promise(function (e, t) {
                      _this8._resolveSocketClose = e;
                    }), this._disposeStompHandler(), e) : (this._changeState(a.INACTIVE), Promise.resolve())));

                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
        }
      }, {
        key: "forceDisconnect",
        value: function forceDisconnect() {
          this._stompHandler && this._stompHandler.forceDisconnect();
        }
      }, {
        key: "_disposeStompHandler",
        value: function _disposeStompHandler() {
          this._stompHandler && (this._stompHandler.dispose(), this._stompHandler = null);
        }
      }, {
        key: "publish",
        value: function publish(e) {
          this._stompHandler.publish(e);
        }
      }, {
        key: "watchForReceipt",
        value: function watchForReceipt(e, t) {
          this._stompHandler.watchForReceipt(e, t);
        }
      }, {
        key: "subscribe",
        value: function subscribe(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return this._stompHandler.subscribe(e, t, s);
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this._stompHandler.unsubscribe(e, t);
        }
      }, {
        key: "begin",
        value: function begin(e) {
          return this._stompHandler.begin(e);
        }
      }, {
        key: "commit",
        value: function commit(e) {
          this._stompHandler.commit(e);
        }
      }, {
        key: "abort",
        value: function abort(e) {
          this._stompHandler.abort(e);
        }
      }, {
        key: "ack",
        value: function ack(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          this._stompHandler.ack(e, t, s);
        }
      }, {
        key: "nack",
        value: function nack(e, t) {
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          this._stompHandler.nack(e, t, s);
        }
      }, {
        key: "webSocket",
        get: function get() {
          return this._stompHandler ? this._stompHandler._webSocket : void 0;
        }
      }, {
        key: "disconnectHeaders",
        get: function get() {
          return this._disconnectHeaders;
        },
        set: function set(e) {
          this._disconnectHeaders = e, this._stompHandler && (this._stompHandler.disconnectHeaders = this._disconnectHeaders);
        }
      }, {
        key: "connected",
        get: function get() {
          return !!this._stompHandler && this._stompHandler.connected;
        }
      }, {
        key: "connectedVersion",
        get: function get() {
          return this._stompHandler ? this._stompHandler.connectedVersion : void 0;
        }
      }, {
        key: "active",
        get: function get() {
          return this.state === a.ACTIVE;
        }
      }]);

      return u;
    }();

    var m = function m() {
      _classCallCheck(this, m);
    };

    var _ = function _() {
      _classCallCheck(this, _);
    };

    var b = function b() {
      _classCallCheck(this, b);
    };

    var g = function () {
      function g(e) {
        _classCallCheck(this, g);

        this.client = e;
      }

      _createClass(g, [{
        key: "outgoing",
        get: function get() {
          return this.client.heartbeatOutgoing;
        },
        set: function set(e) {
          this.client.heartbeatOutgoing = e;
        }
      }, {
        key: "incoming",
        get: function get() {
          return this.client.heartbeatIncoming;
        },
        set: function set(e) {
          this.client.heartbeatIncoming = e;
        }
      }]);

      return g;
    }();

    var p = function (_u) {
      _inherits(p, _u);

      function p(e) {
        var _this9;

        _classCallCheck(this, p);

        (_this9 = _possibleConstructorReturn(this, (p.__proto__ || Object.getPrototypeOf(p)).call(this)), _this9), _this9.maxWebSocketFrameSize = 16384, _this9._heartbeatInfo = new g(_this9), _this9.reconnect_delay = 0, _this9.webSocketFactory = e, _this9.debug = function () {
          var _console;

          (_console = console).log.apply(_console, arguments);
        };return _this9;
      }

      _createClass(p, [{
        key: "_parseConnect",
        value: function _parseConnect() {
          var t = void 0,
              s = void 0,
              n = void 0,
              i = {};
          for (var _len = arguments.length, e = Array(_len), _key = 0; _key < _len; _key++) {
            e[_key] = arguments[_key];
          }

          if (e.length < 2) throw new Error("Connect requires at least 2 arguments");if ("function" == typeof e[1]) {
            ;i = e[0];
            s = e[1];
            n = e[2];
            t = e[3];
          } else switch (e.length) {case 6:
              i.login = e[0];
              i.passcode = e[1];
              s = e[2];
              n = e[3];
              t = e[4];
              i.host = e[5];
              break;default:
              i.login = e[0];
              i.passcode = e[1];
              s = e[2];
              n = e[3];
              t = e[4];
          }return [i, s, n, t];
        }
      }, {
        key: "connect",
        value: function connect() {
          var t = this._parseConnect.apply(this, arguments);t[0] && (this.connectHeaders = t[0]), t[1] && (this.onConnect = t[1]), t[2] && (this.onStompError = t[2]), t[3] && (this.onWebSocketClose = t[3]), _get(p.prototype.__proto__ || Object.getPrototypeOf(p.prototype), "activate", this).call(this);
        }
      }, {
        key: "disconnect",
        value: function disconnect(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          e && (this.onDisconnect = e), this.disconnectHeaders = t, _get(p.prototype.__proto__ || Object.getPrototypeOf(p.prototype), "deactivate", this).call(this);
        }
      }, {
        key: "send",
        value: function send(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
          var n = !1 === (t = Object.assign({}, t))["content-length"];n && delete t["content-length"], this.publish({ destination: e, headers: t, body: s, skipContentLengthHeader: n });
        }
      }, {
        key: "reconnect_delay",
        set: function set(e) {
          this.reconnectDelay = e;
        }
      }, {
        key: "ws",
        get: function get() {
          return this.webSocket;
        }
      }, {
        key: "version",
        get: function get() {
          return this.connectedVersion;
        }
      }, {
        key: "onreceive",
        get: function get() {
          return this.onUnhandledMessage;
        },
        set: function set(e) {
          this.onUnhandledMessage = e;
        }
      }, {
        key: "onreceipt",
        get: function get() {
          return this.onUnhandledReceipt;
        },
        set: function set(e) {
          this.onUnhandledReceipt = e;
        }
      }, {
        key: "heartbeat",
        get: function get() {
          return this._heartbeatInfo;
        },
        set: function set(e) {
          this.heartbeatIncoming = e.incoming, this.heartbeatOutgoing = e.outgoing;
        }
      }]);

      return p;
    }(u);

    var y = function () {
      function y() {
        _classCallCheck(this, y);
      }

      _createClass(y, null, [{
        key: "client",
        value: function client(e, t) {
          null == t && (t = h.default.protocolVersions());return new p(function () {
            return new (y.WebSocketClass || WebSocket)(e, t);
          });
        }
      }, {
        key: "over",
        value: function over(e) {
          var t = void 0;return "function" == typeof e ? t = e : (console.warn("Stomp.over did not receive a factory, auto reconnect will not work. Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over"), t = function t() {
            return e;
          }), new p(t);
        }
      }]);

      return y;
    }();

    y.WebSocketClass = null;
  }]);
});
//# sourceMappingURL=stomp.umd.min.js.map